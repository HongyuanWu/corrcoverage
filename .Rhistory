freq$Probability <- 1/nrow(freq)
sum(freq$Probability)
MAF <- colMeans(freq[,snps]-1)
CV <- sample(snps[which(colMeans(haps)>0.1)],1)
iCV <- sub("s","",CV) # index of cv
g1 <- 1.1
z0 <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
N0 <- 5000 # number of controls
N1 <- 5000 # number of cases
var <- Var.data.cc(f = MAF, N = N1+N0, s = N1/(N0+N1)) # variance of estimated effect size
postprobs <- ppfunc(z = z0, V = var)
plot(postprobs, main = "Posterior probabilities of variants")
abline(v = iCV, col = 2)
credset(pp = postprobs,
# CV = iCV,
thr = 0.9
)
credset(pp = postprobs,
# CV = iCV,
thr = 0.9
)
credset(pp = postprobs,
CV = iCV,
thr = 0.9
)
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
Var.data.cc <- function(f, N, s) {
1 / (2 * N * f * (1 - f) * s * (1 - s))
}
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
corrcov <- function(z0, f, N0, N1, Sigma, thr) {
ph0.tmp <- z0_pp(z0)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
pp0 <- ppfunc(z0)  # posterior probs of system
varbeta <- Var.data.cc(f, N = N0 + N1, N1/(N0 + N1))  # variance of beta
muhat.gam <- mu_est(sum(abs(z0) * pp0))  # estimate for true effect at CV
corrected_cov(mu = muhat.gam, varbeta = varbeta, Sigma = LD, pp0 = pp0, thresh=thr)
}
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
devtools::load_all()
corrcov <- function(z0, f, N0, N1, Sigma, thr) {
ph0.tmp <- z0_pp(z0)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
pp0 <- ppfunc(z0)  # posterior probs of system
varbeta <- coloc:::Var.data.cc(f, N = N0 + N1, N1/(N0 + N1))  # variance of beta
muhat.gam <- mu_est(sum(abs(z0) * pp0))  # estimate for true effect at CV
corrected_cov(mu = muhat.gam, varbeta = varbeta, Sigma = LD, pp0 = pp0, thresh=thr)
}
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
devtools::load_all()
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
devtools::load_all()
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
ph0.tmp <- z0_pp(z0)
devtools::load_all()
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
ph0.tmp <- z0_pp(z0, f, type = "cc", N = N0+N1, s = N1/(N0+N1), W = 0.2)
f=MAF
ph0.tmp <- z0_pp(z0, f, type = "cc", N = N0+N1, s = N1/(N0+N1), W = 0.2)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
pp0 <- ppfunc(z0)
varbeta <- Var.data.cc(f, N0+N1, N1/(N0+N1))
pp0 <- ppfunc(z0, V = varbeta)
muhat.gam <- mu_est(sum(abs(z0) * pp0))
corrected_cov(mu = muhat.gam, varbeta = varbeta, Sigma = LD, pp0 = pp0, thresh=thr)
corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh=thr)
devtools::load_all()
corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
corrected_cov <- function(mu, nsnps = 200, V, Sigma, pp0, thresh) {
temp <- diag(x = mu, nrow = nsnps, ncol = nsnps)
zj <- do.call(c, apply(temp, 1, list))  # nsnp zj vectors for each snp considered causal
# simulate pp systems
pps <- mapply(zj_pp, zj, V, MoreArgs = list(Sigma = LD), SIMPLIFY = FALSE)
# consider different CV as causal in each list
n_pps <- length(pps)
args <- 1:nsnps
# obtain credible set for each simulation
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, args[x], thr = thresh) %>% rbindlist()
})
invlogit <- function(x) exp(x)/(1 + exp(x))
logit <- function(x) log(x/(1 - x))
# resize claimed coverage resize so don't have 0 on denominator
resize <- function(x) {
x[x > 0.99999999] <- 0.999999
return(x)
}
claim.cov <- lapply(d5, function(p) resize(p$claimed.cov))
logitclaimed <- lapply(claim.cov, function(p) logit(p))
y <- mapply(cbind, d5, logit.claim = logitclaimed, SIMPLIFY = FALSE)
# if get error when fitting model use mean(covered)
model <- function(y) {
out <- tryCatch({
lapply(y, pred_logit) %>% unlist()
}, error = function(cond) {
lapply(y, pred_na) %>% unlist()
})
return(out)
}
final <- model(y)
# if NaNs, fit intercept only model
if (mean(final) == "NaN") {
final1 <- lapply(d5, pred_na) %>% unlist()
} else {
final1 <- final
}
# final corrected coverage value
sum(final1 * pp0)
}
thr= 0.9
corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
corrected_cov <- function(mu, nsnps = 200, V, Sigma, pp0, thresh) {
temp <- diag(x = mu, nrow = nsnps, ncol = nsnps)
zj <- do.call(c, apply(temp, 1, list))  # nsnp zj vectors for each snp considered causal
# simulate pp systems
pps <- mapply(zj_pp, zj, V, MoreArgs = list(Sigma = LD), SIMPLIFY = FALSE)
# consider different CV as causal in each list
n_pps <- length(pps)
args <- 1:nsnps
# obtain credible set for each simulation
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, args[x], thr = thresh) %>% data.table:::rbindlist()
})
invlogit <- function(x) exp(x)/(1 + exp(x))
logit <- function(x) log(x/(1 - x))
# resize claimed coverage resize so don't have 0 on denominator
resize <- function(x) {
x[x > 0.99999999] <- 0.999999
return(x)
}
claim.cov <- lapply(d5, function(p) resize(p$claimed.cov))
logitclaimed <- lapply(claim.cov, function(p) logit(p))
y <- mapply(cbind, d5, logit.claim = logitclaimed, SIMPLIFY = FALSE)
# if get error when fitting model use mean(covered)
model <- function(y) {
out <- tryCatch({
lapply(y, pred_logit) %>% unlist()
}, error = function(cond) {
lapply(y, pred_na) %>% unlist()
})
return(out)
}
final <- model(y)
# if NaNs, fit intercept only model
if (mean(final) == "NaN") {
final1 <- lapply(d5, pred_na) %>% unlist()
} else {
final1 <- final
}
# final corrected coverage value
sum(final1 * pp0)
}
corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
devtools::install_github("annahutch/corrcoverage")
library(corrcoverage)
?corrcov
devtools::load_all()
muhatgam
muhat
muhat.gam
temp <- diag(x = muhat.gam, nrow = nsnps, ncol = nsnps)
temp
zj <- do.call(c, apply(temp, 1, list))
pps <- mapply(zj_pp, zj, V, MoreArgs = list(Sigma = LD), SIMPLIFY = FALSE)
pps <- mapply(zj_pp, zj, varbeta, MoreArgs = list(Sigma = LD), SIMPLIFY = FALSE)
n_pps <- length(pps)
args <- 1:nsnps
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, args[x], MoreArgs = list(thr = thresh)) %>% data.table:::rbindlist()
})
apply(pps[[x]], 1, ) %>% data.table:::rbindlist()
})
invlogit <- function(x) exp(x)/(1 + exp(x))
logit <- function(x) log(x/(1 - x))
# resize claimed coverage resize so don't have 0 on denominator
resize <- function(x) {
x[x > 0.99999999] <- 0.999999
return(x)
}
claim.cov <- lapply(d5, function(p) resize(p$claimed.cov))
logitclaimed <- lapply(claim.cov, function(p) logit(p))
y <- mapply(cbind, d5, logit.claim = logitclaimed, SIMPLIFY = FALSE)
# if get error when fitting model use mean(covered)
model <- function(y) {
out <- tryCatch({
lapply(y, pred_logit) %>% unlist()
}, error = function(cond) {
lapply(y, pred_na) %>% unlist()
})
return(out)
}
final <- model(y)
# if NaNs, fit intercept only model
if (mean(final) == "NaN") {
final1 <- lapply(d5, pred_na) %>% unlist()
} else {
final1 <- final
}
# final corrected coverage value
sum(final1 * pp0)
}
#' Obtain corrected coverage estimate
#'
#' This function only requires the marginal summary statistics from GWAS
#' @rdname corrcov
#' @title corrcov
#' @param z0 Marginal z-scores
#' @param f Minor allele frequencies
#' @param N0 Number of controls
#' @param N1 Number of cases
#' @param Sigma SNP correlation matrix
#' @param thr Minimum threshold for fine-mapping experiment
#' @return Corrected coverage estimate
corrcov <- function(z0, f, N0, N1, Sigma, thr) {
ph0.tmp <- z0_pp(z0, f, type = "cc", N = N0+N1, s = N1/(N0+N1), W = 0.2)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
varbeta <- Var.data.cc(f, N0+N1, N1/(N0+N1))  # variance of beta
pp0 <- ppfunc(z0, V = varbeta)  # posterior probs of system
muhat.gam <- mu_est(sum(abs(z0) * pp0))  # estimate for true effect at CV
}
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, CV = args[x], thr = thresh) %>% data.table:::rbindlist()
})
thresh=0.9
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, CV = args[x], thr = thresh) %>% data.table:::rbindlist()
})
d5
thr=0.9
corr.func(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
corrrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
- [x] | Marginal z-scores | Posterior Probabilties | `z0_pp`
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, collapse = TRUE)
set.seed(2)
library(corrcoverage)
library(simGWAS)
nsnps <- 200
nhaps <- 1000
lag <- 5 # genotypes are correlated between neighbouring variants
maf <- runif(nsnps+lag,0.05,0.5) # common SNPs
laghaps <- do.call("cbind", lapply(maf, function(f) rbinom(nhaps,1,f)))
haps <- laghaps[,1:nsnps]
for(j in 1:lag)
haps <- haps + laghaps[,(1:nsnps)+j]
haps <- round(haps/matrix(apply(haps,2,max),nhaps,nsnps,byrow=TRUE))
snps <- colnames(haps) <- paste0("s",1:nsnps)
freq <- as.data.frame(haps+1)
freq$Probability <- 1/nrow(freq)
sum(freq$Probability)
MAF <- colMeans(freq[,snps]-1)
CV <- sample(snps[which(colMeans(haps)>0.1)],1)
iCV <- sub("s","",CV) # index of cv
g1 <- 1.1
z0 <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
N0 <- 5000 # number of controls
N1 <- 5000 # number of cases
var <- Var.data.cc(f = MAF, N = N1+N0, s = N1/(N0+N1)) # variance of estimated effect size
postprobs <- ppfunc(z = z0, V = var)
plot(postprobs, main = "Posterior probabilities of variants")
abline(v = iCV, col = 2)
credset(pp = postprobs,
# CV = iCV,
thr = 0.9
)
cs <- credset(pp = postprobs,
CV = iCV,
thr = 0.9
)
cs
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
corrected_cov_estimate
devtools::load_all()
corrcov <- function(z0, f, N0, N1, Sigma, thr) {
ph0.tmp <- z0_pp(z0, f, type = "cc", N = N0+N1, s = N1/(N0+N1), W = 0.2)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
varbeta <- Var.data.cc(f, N0+N1, N1/(N0+N1))  # variance of beta
pp0 <- ppfunc(z0, V = varbeta)  # posterior probs of system
muhat.gam <- mu_est(sum(abs(z0) * pp0))  # estimate for true effect at CV
cor.cov <- corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
print(cor.cov)
}
devtools::load_all()
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
data.frame("corrcoverage" = corrected_cov_estimate, "claimedcoverage" = cs$claimed.cov, "threshold" = 0.9)
install.packages("formatR")
formatR::tidy_dir("R")
devtools::load_all()
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
pps <- ppfunc.mat(z0.tmp) # find pps
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
zstar = z0.tmp
z0.tmp
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
nrep = 1000
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% rbindlist() # form cred sets
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% data.table:::rbindlist() # form cred sets
true.cov.est <- mean(cs$covered) # average covered col
true.cov.est
ppfunc.mat <- function(zstar, V, W=0.2){
r <- matrix(W^2/(W^2 + V), nrow=nrow(zstar), ncol=ncol(zstar), byrow=TRUE) # see wakefield paper
bf = 0.5 * (log(1 - r) + (r * zstar^2))
denom <- apply(bf, 1, coloc:::logsum) # logsum(x) = max(x) + log(sum(exp(x - max(x)))) so sum is not inf
pp.tmp <- exp(bf - matrix(denom, nrow=nrow(bf),ncol=ncol(bf))) # convert back from log scale
pp.tmp / rowSums(pp.tmp)
}
pps <- ppfunc.mat(z0.tmp, V = varbeta)
set.seed(2)
library(corrcoverage)
nsnps <- 200
nhaps <- 1000
lag <- 5 # genotypes are correlated between neighbouring variants
maf <- runif(nsnps+lag,0.05,0.5) # common SNPs
laghaps <- do.call("cbind", lapply(maf, function(f) rbinom(nhaps,1,f)))
haps <- laghaps[,1:nsnps]
for(j in 1:lag)
haps <- haps + laghaps[,(1:nsnps)+j]
haps <- round(haps/matrix(apply(haps,2,max),nhaps,nsnps,byrow=TRUE))
snps <- colnames(haps) <- paste0("s",1:nsnps)
freq <- as.data.frame(haps+1)
freq$Probability <- 1/nrow(freq)
sum(freq$Probability)
MAF <- colMeans(freq[,snps]-1)
library(simGWAS)
CV <- sample(snps[which(colMeans(haps)>0.1)],1)
iCV <- sub("s","",CV) # index of cv
g1 <- 1.1
z0 <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
N0 <- 5000 # number of controls
N1 <- 5000 # number of cases
var <- Var.data.cc(f = MAF, N = N1+N0, s = N1/(N0+N1)) # variance of estimated effect size
postprobs <- ppfunc(z = z0, V = var)
plot(postprobs, main = "Posterior probabilities of variants")
abline(v = iCV, col = 2)
thresh <- 0.9
credset(pp = postprobs,
# CV = iCV,
thr = thresh
)
cs <- credset(pp = postprobs,
CV = iCV,
thr = thresh
)
cs
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = thresh)
data.frame("Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% data.table:::rbindlist() # form cred sets
true.cov.est <- mean(cs$covered) # average covered col
true.cov.est
data.frame("Empirical Coverage" = true.cov.est, "Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)
data.frame("Empirical Coverage" = true.cov.est, "Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)[1,]
devtools::use_travis()
library(corrcoverage)
?ppfunc.mat
devtools::load_all()
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
rm(corrcov)
rm(corrected_cov)
rm(credset)
rm(ppfunc)
rm(ppfunc.mat)
rm(Var.data.cc())
rm(Var.data.cc
)
libary(corrcov())
library(corrcoverage)
?ppfunc.mat
ppfunc.mat()
ppfunc.mat()
devtools::load_all()
pps <- ppfunc.mat(z0.tmp, V = var) # find pps
pps
knitr::opts_chunk$set(echo = TRUE)
library(formatR)
formatR::tidy_source()
library(data.table)
library(dplyr)
set.seed(2)
library(corrcoverage)
pps <- ppfunc.mat(z0.tmp, V = var) # find pps
pps
knit_with_parameters('~/cs.package/corrcoverage/vignettes/my-vignette.Rmd')
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
uninstall.packages("corrcoverage")
remove.packages("corrcoverage")
devtools::document()
devtools::load_all()
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
getwd()
evtools::check()
devtools::check()
install.packages("corrcoverage")
install.packages("corrcoverage")
devtools::build()
getwd()
install(corrcoverage)
devtools::install(corrcoverage)
install.packages(corrcoverage)
install.packages("corrcoverage")
install.packages("corrcoverage")
devtools::install(corrcoverage)
devtools::install("corrcoverage")
getwd()
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(dplyr)
set.seed(2)
library(corrcoverage)
devtools::build()
devtools::document()
devtools::install(corrcoverage)
devtools::load_all()
library(corrcoverage)
install.packages(corrcoverage)
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
library(corrcoverage)
devtools::build()
getwd()
devtools::build()
devtools::install()
devtools::document()
devtools::install()
