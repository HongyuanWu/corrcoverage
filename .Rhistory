plot(postprobs, main = "Posterior probabilities of variants")
abline(v = iCV, col = 2)
credset(pp = postprobs,
# CV = iCV,
thr = 0.9
)
cs <- credset(pp = postprobs,
CV = iCV,
thr = 0.9
)
cs
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
corrected_cov_estimate
devtools::load_all()
corrcov <- function(z0, f, N0, N1, Sigma, thr) {
ph0.tmp <- z0_pp(z0, f, type = "cc", N = N0+N1, s = N1/(N0+N1), W = 0.2)
ph0 <- ph0.tmp[1]  # prob of the null
pp0dash <- ph0.tmp[-1]  # pps including the null
varbeta <- Var.data.cc(f, N0+N1, N1/(N0+N1))  # variance of beta
pp0 <- ppfunc(z0, V = varbeta)  # posterior probs of system
muhat.gam <- mu_est(sum(abs(z0) * pp0))  # estimate for true effect at CV
cor.cov <- corrected_cov(mu = muhat.gam, V = varbeta, Sigma = LD, pp0 = pp0, thresh = thr)
print(cor.cov)
}
devtools::load_all()
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = 0.9)
data.frame("corrcoverage" = corrected_cov_estimate, "claimedcoverage" = cs$claimed.cov, "threshold" = 0.9)
install.packages("formatR")
formatR::tidy_dir("R")
devtools::load_all()
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
pps <- ppfunc.mat(z0.tmp) # find pps
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
zstar = z0.tmp
z0.tmp
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
nrep = 1000
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% rbindlist() # form cred sets
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% data.table:::rbindlist() # form cred sets
true.cov.est <- mean(cs$covered) # average covered col
true.cov.est
ppfunc.mat <- function(zstar, V, W=0.2){
r <- matrix(W^2/(W^2 + V), nrow=nrow(zstar), ncol=ncol(zstar), byrow=TRUE) # see wakefield paper
bf = 0.5 * (log(1 - r) + (r * zstar^2))
denom <- apply(bf, 1, coloc:::logsum) # logsum(x) = max(x) + log(sum(exp(x - max(x)))) so sum is not inf
pp.tmp <- exp(bf - matrix(denom, nrow=nrow(bf),ncol=ncol(bf))) # convert back from log scale
pp.tmp / rowSums(pp.tmp)
}
pps <- ppfunc.mat(z0.tmp, V = varbeta)
set.seed(2)
library(corrcoverage)
nsnps <- 200
nhaps <- 1000
lag <- 5 # genotypes are correlated between neighbouring variants
maf <- runif(nsnps+lag,0.05,0.5) # common SNPs
laghaps <- do.call("cbind", lapply(maf, function(f) rbinom(nhaps,1,f)))
haps <- laghaps[,1:nsnps]
for(j in 1:lag)
haps <- haps + laghaps[,(1:nsnps)+j]
haps <- round(haps/matrix(apply(haps,2,max),nhaps,nsnps,byrow=TRUE))
snps <- colnames(haps) <- paste0("s",1:nsnps)
freq <- as.data.frame(haps+1)
freq$Probability <- 1/nrow(freq)
sum(freq$Probability)
MAF <- colMeans(freq[,snps]-1)
library(simGWAS)
CV <- sample(snps[which(colMeans(haps)>0.1)],1)
iCV <- sub("s","",CV) # index of cv
g1 <- 1.1
z0 <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq # reference haplotypes
)
N0 <- 5000 # number of controls
N1 <- 5000 # number of cases
var <- Var.data.cc(f = MAF, N = N1+N0, s = N1/(N0+N1)) # variance of estimated effect size
postprobs <- ppfunc(z = z0, V = var)
plot(postprobs, main = "Posterior probabilities of variants")
abline(v = iCV, col = 2)
thresh <- 0.9
credset(pp = postprobs,
# CV = iCV,
thr = thresh
)
cs <- credset(pp = postprobs,
CV = iCV,
thr = thresh
)
cs
LD <- cor2(haps)
corrected_cov_estimate <- corrcov(z0, f = MAF, N0, N1, Sigma = LD, thr = thresh)
data.frame("Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)
z0.tmp <- simulated_z_score(N0=5000, # number of controls
N1=5000, # number of cases
snps=snps, # column names in freq of SNPs for which Z scores should be generated
W=CV, # causal variants, subset of snps
gamma.W=log(g1), # log odds ratios
freq=freq, # reference haplotypes
nrep = 1000
)
pps <- ppfunc.mat(z0.tmp, V = varbeta) # find pps
cs <- apply(pps, 1, credset, CV = iCV, thr = thresh) %>% data.table:::rbindlist() # form cred sets
true.cov.est <- mean(cs$covered) # average covered col
true.cov.est
data.frame("Empirical Coverage" = true.cov.est, "Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)
data.frame("Empirical Coverage" = true.cov.est, "Corrected Coverage" = corrected_cov_estimate, "Claimed Coverage" = cs$claimed.cov, "Threshold" = thresh)[1,]
devtools::use_travis()
library(corrcoverage)
?ppfunc.mat
devtools::load_all()
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
rm(corrcov)
rm(corrected_cov)
rm(credset)
rm(ppfunc)
rm(ppfunc.mat)
rm(Var.data.cc())
rm(Var.data.cc
)
libary(corrcov())
library(corrcoverage)
?ppfunc.mat
ppfunc.mat()
ppfunc.mat()
devtools::load_all()
pps <- ppfunc.mat(z0.tmp, V = var) # find pps
pps
knitr::opts_chunk$set(echo = TRUE)
library(formatR)
formatR::tidy_source()
library(data.table)
library(dplyr)
set.seed(2)
library(corrcoverage)
pps <- ppfunc.mat(z0.tmp, V = var) # find pps
pps
knit_with_parameters('~/cs.package/corrcoverage/vignettes/my-vignette.Rmd')
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::load_all()
uninstall.packages("corrcoverage")
remove.packages("corrcoverage")
devtools::document()
devtools::load_all()
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
getwd()
evtools::check()
devtools::check()
install.packages("corrcoverage")
install.packages("corrcoverage")
devtools::build()
getwd()
install(corrcoverage)
devtools::install(corrcoverage)
install.packages(corrcoverage)
install.packages("corrcoverage")
install.packages("corrcoverage")
devtools::install(corrcoverage)
devtools::install("corrcoverage")
getwd()
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(dplyr)
set.seed(2)
library(corrcoverage)
devtools::build()
devtools::document()
devtools::install(corrcoverage)
devtools::load_all()
library(corrcoverage)
install.packages(corrcoverage)
install.packages("corrcoverage")
install.packages("corrcoverage")
library(corrcoverage)
library(corrcoverage)
devtools::build()
getwd()
devtools::build()
devtools::install()
devtools::document()
devtools::install()
install.packages("pkgdown")
devtools::install_github("r-lib/pkgdown")
pkgdown::build_site()
devtools::document()
?ppfunc
?z_sim
pkgdown::template_navbar()
# }
# NOT RUN {
pkgdown::template_reference()
# }
# NOT RUN {
pkgdown::template_articles()
# }
sink("_pkgdown.yml")
template_navbar()
template_reference()
sink()
pkgdown::template_navbar()
pkgdown::template_reference()
sink()
pkgdown::template_navbar()
# }
# NOT RUN {
pkgdown::template_reference()
# }
# NOT RUN {
pkgdown::template_articles()
# }
devtools::load_all()
devtools::install()
pkgdown::build_site()
template_navbar(path = ".")
template_reference(path = ".")
template_articles(path = ".")
pkgdown::template_navbar(path = ".")addterm()
pkgdown::template_navbar(path = ".")
build_site()
pkgdown::build_site()
template_articles(path = ".")
pkgdown::template_articles(path = ".")
pkgdown::template_navbar(path = ".")
devtools::build_vignettes()
devtools::use_vignette("my-vignette")
pkgdown::template_reference()
pkgdown::template_navbar()
pkgdown::template_articles()
devtools::load_all()
devtools::document()
devtools::build()
pkgdown::build_site()
z <- rnorm(100)
z <- z/sum(z)
z <- rnorm(100)
z <- z/sum(z)
var <- 0.1
test_that("post probs sum to 1", {
pp <- ppfunc(z, v = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
expect_that( pp >= 0, is_true() )
})
install.packages("testthat")
library(testthat)
test_that("post probs sum to 1", {
pp <- ppfunc(z, v = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
expect_that( pp >= 0, is_true() )
})
library(corrcoverage)
test_that("post probs sum to 1", {
pp <- ppfunc(z, v = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
expect_that( pp >= 0, is_true() )
})
test_that("post probs sum to 1", {
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
expect_that( pp >= 0, is_true() )
})
test_that("post probs sum to 1", {
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)) )
})
test_that("post probs sum to 1", {
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
})
test_that("post probs sum to 1", {
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)) )
expect_that( sum(pp), equals(1) )
expect_that( pp > 0, is_true() )
})
devtools::test()
1.5/qnorm(0.95)
2/qnorm(0.95)
log(2)/qnorm(0.95)
1.5/qnorm(0.99)
log(1.5)/qnorm(0.99)
log(1.5)/qnorm(0.95)
1.5/qnorm(0.95)
2/qnorm(0.95)
1.5/qnorm(0.95)
log(2)/qnorm(0.95)
mu_est <- function(X) {
y = seq(0, 20, 0.005)
x <- sapply(y, function(m) mean(abs(rnorm(50000, mean = m))))
approx(x, y, xout = X)$y
}
test <- mu_est(2)
test
y = seq(0, 20, 0.005)
x <- sapply(y, function(m) mean(abs(rnorm(50000, mean = m))))
plot(x,y)
par(mfrow=c(1,2))
plot(x,y)
plot(x,y,xlim=c(0,2),ylim=c(0,2))
plot(x,y)
abline(0, 1, col = 2)
plot(x,y,xlim=c(0,2),ylim=c(0,2))
abline(0, 1, col = 2)
par(mfrow=c(1,2))
plot(x, y, xlab="E(|z|)", ylab="mu", main = "Find mu value given expected |Z|")
abline(0, 1, col = 2)
plot(x, y, xlim=c(0,2), ylim=c(0,2), xlab="E(|z|)", ylab="mu", main = "Zoom in to bottom left")
abline(0, 1, col = 2)
corrected_cov <- function(mu, nsnps = 200, V, Sigma, pp0, thresh, size) {
# find size of credible set
if (missing(size)) {
cs <- credset(pp0, thr = thresh)
claim0 <- cs$claimed.cov
} else {
claim0 <- size
}
# form joint z-score vectors
temp <- diag(x = mu, nrow = nsnps, ncol = nsnps)
zj <- do.call(c, apply(temp, 1, list))  # nsnp zj vectors for each snp considered causal
# simulate pp systems
pps <- mapply(zj_pp, zj, V, MoreArgs = list(Sigma = LD), SIMPLIFY = FALSE)
# consider different CV as causal in each list
n_pps <- length(pps)
args <- 1:nsnps
# obtain credible set for each simulation
d5 <- lapply(1:n_pps, function(x) {
apply(pps[[x]], 1, credset, CV = args[x], thr = thresh) %>% data.table::rbindlist()
})
invlogit <- function(x) exp(x)/(1 + exp(x))
logit <- function(x) log(x/(1 - x))
# resize claimed coverage so not dividing by 0
resize <- function(x) {
x[x > 0.99999999] <- 0.999999
return(x)
}
claim.cov <- lapply(d5, function(p) resize(p$claimed.cov))
logitclaimed <- lapply(claim.cov, function(p) logit(p))
y <- mapply(cbind, d5, logit.claim = logitclaimed, SIMPLIFY = FALSE)
# if get error when fitting model use mean(covered)
model <- function(y) {
out <- tryCatch({
lapply(y, pred_logit, size) %>% unlist()
}, error = function(cond) {
lapply(y, pred_na) %>% unlist()
})
return(out)
}
final <- model(y)
# if NaNs, fit intercept only model
if (mean(final) == "NaN") {
final1 <- lapply(d5, pred_na) %>% unlist()
} else {
final1 <- final
}
# final corrected coverage value
sum(final1 * pp0)
}
formatR::tide_dir(“R”)
formatR::tide_dir("R")
library(formatR)
formatR::tide_dir("R")
formatR:::tide_dir("R")
formatR:::tidy_dir("R")
z <- rnorm(100)
z <- z/sum(z)
pvals <- pnorm(abs(z),lower.tail = FALSE)*2
var <- 0.1
maf <- rep(0.05, length(z))
pp <- ppfunc(z, V = var)
tabledata <- readRDS("testdata.RDS")
getwd()
tabledata <- readRDS("~/corrcoverage/testdata.RDS")
tabledata <- readRDS("./corrcoverage/testdata.RDS")
data(testdata.RDS)
data("testdata.RDS")
getwd()
tabledata <- readRDS("../corrcoverage/testdata.RDS")
getwd()
tabledata <- readRDS("./tests/testdata.RDS")
tabledata
test_that("prediction functions output value between 0 and 1", {
x <- pred_logit(tabledata, size = mean(tabledata$claimed.cov))
expect_true(x >= 0 & x <= 1)
x1 <- pred_na(tabledata)
expect_true(x1 >= 0 & x1 <= 1)
})
library(testthat)
test_that("prediction functions output value between 0 and 1", {
x <- pred_logit(tabledata, size = mean(tabledata$claimed.cov))
expect_true(x >= 0 & x <= 1)
x1 <- pred_na(tabledata)
expect_true(x1 >= 0 & x1 <= 1)
})
library(corrcoverage)
test_that("prediction functions output value between 0 and 1", {
x <- pred_logit(tabledata, size = mean(tabledata$claimed.cov))
expect_true(x >= 0 & x <= 1)
x1 <- pred_na(tabledata)
expect_true(x1 >= 0 & x1 <= 1)
})
pvals.pp.null <- pvals_pp(pvals, f = maf, type = "cc", N = 10000, s = 0.5)
pvals.pp.null>=0
expect_that( length(pp), equals(length(z)))
devtools::load_all()
devtools::document()
devtools::test()
devtools::test()
test_that("prediction functions output value between 0 and 1", {
x <- pred_logit(tabledata, size = mean(tabledata$claimed.cov))
expect_true(x >= 0 & x <= 1)
x1 <- pred_na(tabledata)
expect_true(x1 >= 0 & x1 <= 1)
})
head(tabledata)
z <- rnorm(100)
z <- z/sum(z)
pvals <- pnorm(abs(z),lower.tail = FALSE)*2
var <- 0.1
maf <- rep(0.05, length(z))
tabledata <- readRDS("./tests/testdata.RDS")
tabledata
test_that("length of posterior probs is the same as input (or plus 1 if null model considered)", {
pvals.pp.null <- pvals_pp(pvals, f = maf, type = "cc", N = 10000, s = 0.5)
expect_that( length(pvals.pp.null), equals(length(z)+1))
expect_true(pvals.pp.null>=0)
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)))
expect_true(pp>=0)
z.pp.null <- z0_pp(z, f = maf, type = "cc", N = 10000, s = 0.5)
expect_that( length(z.pp.null), equals(length(z)+1))
expect_true(z.pp.null>=0)
})
pvals.pp.null
range(pvals.pp.null)
pvals.pp.null>=0
expect_true(pvals.pp.null>=0)
expect_true(all(pvals.pp.null>=0))
test_that("length of posterior probs is the same as input (or plus 1 if null model considered)", {
pvals.pp.null <- pvals_pp(pvals, f = maf, type = "cc", N = 10000, s = 0.5)
expect_that( length(pvals.pp.null), equals(length(z)+1))
expect_true(all(pvals.pp.null>=0))
pp <- ppfunc(z, V = var)
expect_that( length(pp), equals(length(z)))
expect_true(all(pp>=0))
z.pp.null <- z0_pp(z, f = maf, type = "cc", N = 10000, s = 0.5)
expect_that( length(z.pp.null), equals(length(z)+1))
expect_true(all(z.pp.null>=0))
})
test_that("prediction functions output value between 0 and 1", {
x <- pred_logit(tabledata, size = mean(tabledata$claimed.cov))
expect_true(x >= 0 & x <= 1)
x1 <- pred_na(tabledata)
expect_true(x1 >= 0 & x1 <= 1)
})
devtools::test()
•	Devtools::install()
Devtools::install()
devtools::install()
devtools::test()
devtools::install()
pkgdown::build_site()
